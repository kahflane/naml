///
/// Rust Code Generator
///
/// This module generates Rust source code from naml AST. It handles:
/// - Type mappings (naml types â†’ Rust types)
/// - Expression codegen (literals, binary ops, calls)
/// - Statement codegen (var, if, while, for, return)
/// - Function and struct definitions
///

mod expressions;
mod statements;
mod types;

use lasso::Rodeo;

use crate::ast::{FunctionItem, Item, SourceFile, StructItem};
use crate::codegen::CodegenError;

pub struct RustGenerator<'a> {
    interner: &'a Rodeo,
    output: String,
    indent: usize,
}

impl<'a> RustGenerator<'a> {
    pub fn new(interner: &'a Rodeo) -> Self {
        Self {
            interner,
            output: String::new(),
            indent: 0,
        }
    }

    pub fn generate(mut self, ast: &SourceFile<'_>) -> Result<String, CodegenError> {
        self.emit_prelude();

        for item in &ast.items {
            match item {
                Item::Struct(s) => self.emit_struct(s)?,
                Item::Function(f) => self.emit_function(f)?,
                Item::TopLevelStmt(_stmt) => {
                    return Err(CodegenError::Unsupported(
                        "Top-level statements outside main not yet supported".to_string(),
                    ));
                }
                Item::Enum(_) => {
                    return Err(CodegenError::Unsupported("Enums not yet supported".to_string()));
                }
                Item::Interface(_) => {
                    return Err(CodegenError::Unsupported(
                        "Interfaces not yet supported".to_string(),
                    ));
                }
                Item::Exception(_) => {
                    return Err(CodegenError::Unsupported(
                        "Exceptions not yet supported".to_string(),
                    ));
                }
                Item::Import(_) | Item::Use(_) => {}
                Item::Extern(_) => {
                    return Err(CodegenError::Unsupported(
                        "Extern declarations not yet supported".to_string(),
                    ));
                }
            }
        }

        Ok(self.output)
    }

    fn emit_prelude(&mut self) {
        self.writeln("// Generated by naml compiler");
        self.writeln("#![allow(unused_variables)]");
        self.writeln("#![allow(unused_mut)]");
        self.writeln("#![allow(dead_code)]");
        self.writeln("");
    }

    fn emit_struct(&mut self, s: &StructItem) -> Result<(), CodegenError> {
        let name = self.interner.resolve(&s.name.symbol);

        if s.is_public {
            self.write("pub ");
        }

        self.writeln(&format!("struct {} {{", name));
        self.indent += 1;

        for field in &s.fields {
            let field_name = self.interner.resolve(&field.name.symbol);
            let field_type = types::naml_to_rust(&field.ty, self.interner);

            self.write_indent();
            if field.is_public {
                self.write("pub ");
            }
            self.writeln(&format!("{}: {},", field_name, field_type));
        }

        self.indent -= 1;
        self.writeln("}");
        self.writeln("");

        Ok(())
    }

    fn emit_function(&mut self, f: &FunctionItem<'_>) -> Result<(), CodegenError> {
        let name = self.interner.resolve(&f.name.symbol);

        if f.receiver.is_some() {
            return Ok(());
        }

        if f.is_async {
            return Err(CodegenError::Unsupported(
                "Async functions not yet supported".to_string(),
            ));
        }

        if f.is_public {
            self.write("pub ");
        }

        self.write(&format!("fn {}(", name));

        for (i, param) in f.params.iter().enumerate() {
            if i > 0 {
                self.write(", ");
            }
            let param_name = self.interner.resolve(&param.name.symbol);
            let param_type = types::naml_to_rust(&param.ty, self.interner);
            self.write(&format!("{}: {}", param_name, param_type));
        }

        self.write(")");

        if let Some(ref return_ty) = f.return_ty {
            let rust_ty = types::naml_to_rust(return_ty, self.interner);
            self.write(&format!(" -> {}", rust_ty));
        }

        if let Some(ref body) = f.body {
            self.writeln(" {");
            self.indent += 1;

            statements::emit_block(self, body)?;

            self.indent -= 1;
            self.writeln("}");
        } else {
            self.writeln(";");
        }

        self.writeln("");

        Ok(())
    }

    pub(crate) fn write(&mut self, s: &str) {
        self.output.push_str(s);
    }

    pub(crate) fn writeln(&mut self, s: &str) {
        self.write_indent();
        self.output.push_str(s);
        self.output.push('\n');
    }

    pub(crate) fn write_indent(&mut self) {
        for _ in 0..self.indent {
            self.output.push_str("    ");
        }
    }

    pub(crate) fn interner(&self) -> &Rodeo {
        self.interner
    }

    pub(crate) fn indent_inc(&mut self) {
        self.indent += 1;
    }

    pub(crate) fn indent_dec(&mut self) {
        self.indent -= 1;
    }
}

pub fn generate(ast: &SourceFile<'_>, interner: &Rodeo) -> Result<String, CodegenError> {
    let generator = RustGenerator::new(interner);
    generator.generate(ast)
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_module_exists() {
        assert!(true);
    }
}
