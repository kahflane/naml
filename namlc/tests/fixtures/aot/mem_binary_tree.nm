use std::collections::arrays::{push, count};

fn insert(vals: [int], lefts: [int], rights: [int], root: int, val: int) -> int {
    var idx: int = count(vals);
    push(vals, val);
    push(lefts, -1);
    push(rights, -1);

    if (root == -1) {
        return idx;
    }

    var cur: int = root;
    var placed: bool = false;
    while (not placed) {
        if (val < vals[cur]!) {
            if (lefts[cur]! == -1) {
                lefts[cur] = idx;
                placed = true;
            } else {
                cur = lefts[cur]!;
            }
        } else {
            if (rights[cur]! == -1) {
                rights[cur] = idx;
                placed = true;
            } else {
                cur = rights[cur]!;
            }
        }
    }
    return root;
}

fn tree_size(lefts: [int], rights: [int], node: int) -> int {
    if (node == -1) {
        return 0;
    }
    return 1 + tree_size(lefts, rights, lefts[node]!)
             + tree_size(lefts, rights, rights[node]!);
}

fn build_complete_tree(vals: [int], lefts: [int], rights: [int], root: int, depth: int, counter: [int]) -> int {
    if (depth <= 0) {
        return root;
    }
    var current_val: int = counter[0]!;
    counter[0] = current_val + 1;
    var new_root: int = insert(vals, lefts, rights, root, current_val);
    new_root = build_complete_tree(vals, lefts, rights, new_root, depth - 1, counter);
    new_root = build_complete_tree(vals, lefts, rights, new_root, depth - 1, counter);
    return new_root;
}

fn main() {
    var vals: [int] = [];
    var lefts: [int] = [];
    var rights: [int] = [];
    var root: int = -1;

    var i: int = 0;
    while (i < 127) {
        root = insert(vals, lefts, rights, root, i);
        i = i + 1;
    }

    var size: int = tree_size(lefts, rights, root);
    println(size);
}
