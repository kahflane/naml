///
/// UDP Metrics Server - Real-time Metrics Aggregator
///
/// A metrics collection system that:
/// - Receives metrics from multiple workers via UDP
/// - Aggregates statistics (count, sum, min, max)
/// - Uses rwlock for read-heavy access pattern
/// - Periodically prints aggregated stats
///
/// Protocol: worker_id|metric_value (e.g., "1|42")
///
/// Usage: Run this server, then run net_udp_metrics_worker.naml
///

use std::threads::{join, with_rwlock};
use std::net::{bind, receive, close, local_addr};
use std::strings::{len, split, has};

fn main() {
    println("=== UDP Metrics Server ===");
    println("");

    // Shared state for aggregated metrics (using rwlock for concurrent access)
    var total_count: rwlock<int> = with_rwlock(0);
    var total_sum: rwlock<int> = with_rwlock(0);
    var min_value: rwlock<int> = with_rwlock(999999);
    var max_value: rwlock<int> = with_rwlock(0);

    // Bind UDP socket
    var socket: int = bind(":9999") catch e {
        println(fmt("Failed to bind: {}", e.message));
        return;
    };

    var addr: string = local_addr(socket);
    println(fmt("Metrics server listening on {}", addr));
    println("Waiting for metrics... (Run net_udp_metrics_worker.naml)");
    println("");

    // Spawn stats printer thread
    spawn {
        stats_printer(total_count, total_sum, min_value, max_value);
    };

    // Receive loop - process up to 100 metrics for demo
    var received_count: int = 0;
    while (received_count < 100) {
        // Receive metric data via UDP
        var data: bytes = receive(socket, 256) catch e {
            println(fmt("Receive error: {}", e.message));
            continue;
        };

        var message: string = data as string;
        var msg_len: int = len(message);

        if (msg_len == 0) {
            continue;
        }

        // Parse message: "worker_id|value"
        var parsed: option<int> = parse_metric(message);
        var value: int = parsed ?? -1;

        if (value >= 0) {
            // Update aggregated stats
            update_stats(value, total_count, total_sum, min_value, max_value);
            received_count = received_count + 1;
        }
    }

    println("");
    println("Received 100 metrics. Shutting down...");

    // Print final stats
    println("");
    println("=== Final Statistics ===");
    rlocked (cnt: int in total_count) {
        println(fmt("Total metrics: {}", cnt));
    }
    rlocked (sum: int in total_sum) {
        println(fmt("Sum of values: {}", sum));
    }
    rlocked (min_val: int in min_value) {
        println(fmt("Min value: {}", min_val));
    }
    rlocked (max_val: int in max_value) {
        println(fmt("Max value: {}", max_val));
    }

    // Calculate average
    var cnt: int = 0;
    var sum: int = 0;
    rlocked (c: int in total_count) {
        cnt = c;
    }
    rlocked (s: int in total_sum) {
        sum = s;
    }

    if (cnt > 0) {
        var avg: int = sum / cnt;
        println(fmt("Average value: {}", avg));
    }

    // Verify expected values
    if (cnt == 100) {
        println("PASS: Received all 100 metrics!");
    } else {
        println(fmt("FAIL: Expected count=100, got count={}", cnt));
    }

    join();
    close(socket);
    println("Server stopped.");
}

fn update_stats(
    value: int,
    total_count: rwlock<int>,
    total_sum: rwlock<int>,
    min_value: rwlock<int>,
    max_value: rwlock<int>
) {
    // Update count
    wlocked (cnt: int in total_count) {
        cnt = cnt + 1;
    }

    // Update sum
    wlocked (sum: int in total_sum) {
        sum = sum + value;
    }

    // Update min
    wlocked (min_val: int in min_value) {
        if (value < min_val) {
            min_val = value;
        }
    }

    // Update max
    wlocked (max_val: int in max_value) {
        if (value > max_val) {
            max_val = value;
        }
    }
}

fn parse_metric(message: string) -> option<int> {
    // Format: "worker_id|value"
    // First check if the delimiter exists
    if (!has(message, "|")) {
        return none;
    }

    var parts: [string] = split(message, "|");

    // Now we know there are at least 2 parts since delimiter exists
    var part0: string = parts[0] ?? "";
    var part1: string = parts[1] ?? "";

    // Both parts must have content
    var len0: int = len(part0);
    var len1: int = len(part1);
    if (len0 == 0 || len1 == 0) {
        return none;
    }

    // Parse value (second part)
    var value: int = part1 as? int ?? -1;

    if (value < 0) {
        return none;
    }

    return some(value);
}

fn stats_printer(
    total_count: rwlock<int>,
    total_sum: rwlock<int>,
    min_value: rwlock<int>,
    max_value: rwlock<int>
) {
    println("[Stats Printer] Started");

    var i: int = 0;
    while (i < 10) {
        sleep(500);

        var cnt: int = 0;
        var sum: int = 0;
        rlocked (c: int in total_count) {
            cnt = c;
        }
        rlocked (s: int in total_sum) {
            sum = s;
        }

        println(fmt("[Stats] Count: {}, Sum: {}", cnt, sum));
        i = i + 1;
    }

    println("[Stats Printer] Finished");
}
