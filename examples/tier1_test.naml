///
/// Tier 1 Integration Test
///
/// Tests the core features implemented in Tier 1:
/// - Enums with unit variants
/// - Enum pattern matching with switch
/// - Option type (some, none, pattern matching)
/// - Maps (creation, indexing, assignment)
/// - Structs (definition, instantiation, field access)
/// - Arrays (creation, count, iteration with for)
/// - Control flow (if, while, for)
///

use std::collections::arrays::count;
use std::testing::*;

enum Color {
    Red,
    Green,
    Blue
}

enum Priority {
    Low,
    Medium,
    High,
    Critical
}

struct Point {
    x: int,
    y: int
}

struct Rectangle {
    width: int,
    height: int
}

fn test_enums() {
    println("=== Enum Tests ===");

    var c1: Color = Color::Red;
    var c2: Color = Color::Green;
    var c3: Color = Color::Blue;

    print("Testing Color::Red: ");
    var c1_matched: int = 0;
    switch (c1) {
        case Red: {
            println("PASS - Red");
            c1_matched = 1;
        }
        case Green: {
            println("FAIL");
            c1_matched = 2;
        }
        case Blue: {
            println("FAIL");
            c1_matched = 3;
        }
    }
    assert_eq(c1_matched, 1, "Color::Red should match Red variant");

    print("Testing Color::Green: ");
    var c2_matched: int = 0;
    switch (c2) {
        case Red: {
            println("FAIL");
            c2_matched = 1;
        }
        case Green: {
            println("PASS - Green");
            c2_matched = 2;
        }
        case Blue: {
            println("FAIL");
            c2_matched = 3;
        }
    }
    assert_eq(c2_matched, 2, "Color::Green should match Green variant");

    print("Testing Color::Blue: ");
    var c3_matched: int = 0;
    switch (c3) {
        case Red: {
            println("FAIL");
            c3_matched = 1;
        }
        case Green: {
            println("FAIL");
            c3_matched = 2;
        }
        case Blue: {
            println("PASS - Blue");
            c3_matched = 3;
        }
    }
    assert_eq(c3_matched, 3, "Color::Blue should match Blue variant");

    var p: Priority = Priority::High;
    print("Testing Priority with default: ");
    var p_matched: int = 0;
    switch (p) {
        case Low: {
            println("FAIL");
            p_matched = 1;
        }
        case High: {
            println("PASS - High");
            p_matched = 2;
        }
        default: {
            println("FAIL - default");
            p_matched = 3;
        }
    }
    assert_eq(p_matched, 2, "Priority::High should match High variant");

    var p2: Priority = Priority::Medium;
    print("Testing default branch: ");
    var p2_matched: int = 0;
    switch (p2) {
        case Low: {
            println("FAIL");
            p2_matched = 1;
        }
        case High: {
            println("FAIL");
            p2_matched = 2;
        }
        default: {
            println("PASS - default matched Medium");
            p2_matched = 3;
        }
    }
    assert_eq(p2_matched, 3, "Priority::Medium should match default branch");
}

fn test_options() {
    println("=== Option Tests ===");

    var opt_some: option<int> = some(42);
    var opt_none: option<int> = none;

    print("Testing force unwrap on some(42): ");
    var unwrapped: int = opt_some!;
    if (unwrapped == 42) {
        println("PASS");
    } else {
        println("FAIL - wrong value");
    }
    assert_eq(unwrapped, 42, "force unwrap on some(42)");

    print("Testing ?? operator on some: ");
    var with_default: int = opt_some ?? 0;
    if (with_default == 42) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(with_default, 42, "?? operator on some should return value");

    print("Testing ?? operator on none: ");
    var none_default: int = opt_none ?? 99;
    if (none_default == 99) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(none_default, 99, "?? operator on none should return default");

    print("Testing ?? with expression: ");
    var first: option<int> = none;
    var result: int = first ?? (10 + 40);
    if (result == 50) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(result, 50, "?? with expression should evaluate correctly");

    var opt_point: option<Point> = some(Point { x: 10, y: 20 });
    print("Testing option<struct> force unwrap: ");
    var pt: Point = opt_point!;
    if (pt.x == 10 and pt.y == 20) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(pt.x, 10, "unwrapped struct x field");
    assert_eq(pt.y, 20, "unwrapped struct y field");
}

fn test_maps() {
    println("=== Map Tests ===");

    var scores: map<string, int> = {};
    scores["alice"] = 100;
    scores["bob"] = 85;
    scores["charlie"] = 92;

    print("Testing map set and get alice: ");
    println(scores["alice"]);

    print("Testing map set and get bob: ");
    println(scores["bob"]);

    print("Testing map set and get charlie: ");
    println(scores["charlie"]);

    scores["alice"] = 95;
    print("Testing map update alice: ");
    println(scores["alice"]);

    var counts: map<string, int> = {};
    counts["a"] = 1;
    counts["b"] = 2;
    counts["c"] = 3;
    print("Testing counts a: ");
    println(counts["a"]);
    print("Testing counts b: ");
    println(counts["b"]);
    print("Testing counts c: ");
    println(counts["c"]);
}

fn test_arrays() {
    println("=== Array Tests ===");

    var numbers: [int] = [10, 20, 30, 40, 50];

    print("Testing array length: ");
    var arr_len: int = count(numbers);
    if (arr_len == 5) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(arr_len, 5, "array length");

    print("Testing for loop iteration: ");
    var sum: int = 0;
    for (i: int, n: int in numbers) {
        sum = sum + n;
    }
    if (sum == 150) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(sum, 150, "array element sum");

    print("Testing indexed for loop: ");
    var idx_sum: int = 0;
    for (i: int, n: int in numbers) {
        idx_sum = idx_sum + i;
    }
    if (idx_sum == 10) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(idx_sum, 10, "array index sum");

    var empty: [int] = [];
    print("Testing empty array length: ");
    var empty_len: int = count(empty);
    if (empty_len == 0) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(empty_len, 0, "empty array length");
}

fn test_structs() {
    println("=== Struct Tests ===");

    var p: Point = Point { x: 5, y: 10 };

    print("Testing struct field x: ");
    if (p.x == 5) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(p.x, 5, "struct field x");

    print("Testing struct field y: ");
    if (p.y == 10) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(p.y, 10, "struct field y");

    var rect: Rectangle = Rectangle { width: 100, height: 50 };

    print("Testing rectangle area: ");
    var area: int = rect.width * rect.height;
    if (area == 5000) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(area, 5000, "rectangle area calculation");

    var nested: Point = Point { x: 15, y: 25 };

    print("Testing nested struct access: ");
    if (nested.x == 15) {
        if (nested.y == 25) {
            println("PASS");
        } else {
            println("FAIL");
        }
    } else {
        println("FAIL");
    }
    assert_eq(nested.x, 15, "nested struct field x");
    assert_eq(nested.y, 25, "nested struct field y");
}

fn test_control_flow() {
    println("=== Control Flow Tests ===");

    print("Testing if-else: ");
    var x: int = 42;
    if (x == 42) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(x, 42, "if-else condition");

    print("Testing while loop: ");
    var count_val: int = 0;
    var i: int = 0;
    while (i < 5) {
        count_val = count_val + 1;
        i = i + 1;
    }
    if (count_val == 5) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(count_val, 5, "while loop iteration count");
    assert_eq(i, 5, "while loop counter final value");

    print("Testing nested if: ");
    var a: int = 10;
    var b: int = 20;
    var nested_ok: bool = false;
    if (a < b) {
        if (b > 15) {
            println("PASS");
            nested_ok = true;
        } else {
            println("FAIL");
        }
    } else {
        println("FAIL");
    }
    assert_true(nested_ok, "nested if condition");

    print("Testing switch with int: ");
    var day: int = 3;
    var day_matched: int = 0;
    switch (day) {
        case 1: {
            println("FAIL");
            day_matched = 1;
        }
        case 2: {
            println("FAIL");
            day_matched = 2;
        }
        case 3: {
            println("PASS");
            day_matched = 3;
        }
        default: {
            println("FAIL");
            day_matched = 4;
        }
    }
    assert_eq(day_matched, 3, "switch with int should match case 3");
}

fn test_combined() {
    println("=== Combined Feature Tests ===");

    print("Testing enum in loop: ");
    var colors: [Color] = [Color::Red, Color::Green, Color::Blue];
    var color_count: int = 0;
    for (c: Color in colors) {
        color_count = color_count + 1;
    }
    if (color_count == 3) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(color_count, 3, "enum array iteration count");

    print("Testing option ?? and else together: ");
    var opt1: option<int> = some(10);
    var opt2: option<int> = none;
    var opt1_value: int = opt1 ?? -1;
    var opt2_value: int = opt2 ?? -1;
    if (opt1_value == 10 and opt2_value == -1) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(opt1_value, 10, "some option ?? default");
    assert_eq(opt2_value, -1, "none option ?? default");

    print("Testing map with computed values x: ");
    var data: map<string, int> = {};
    var base: int = 10;
    data["x"] = base * 2;
    data["y"] = base * 3;
    println(data["x"]);
    print("Testing map with computed values y: ");
    println(data["y"]);

    print("Testing struct in array: ");
    var points: [Point] = [
        Point { x: 1, y: 2 },
        Point { x: 3, y: 4 },
        Point { x: 5, y: 6 }
    ];
    var x_sum: int = 0;
    for (pt: Point in points) {
        x_sum = x_sum + pt.x;
    }
    if (x_sum == 9) {
        println("PASS");
    } else {
        println("FAIL");
    }
    assert_eq(x_sum, 9, "struct array x field sum");
}

fn main() {
    println("========================================");
    println("       NAML Tier 1 Integration Test    ");
    println("========================================");
    println("");

    test_enums();
    println("");

    test_options();
    println("");

    test_maps();
    println("");

    test_arrays();
    println("");

    test_structs();
    println("");

    test_control_flow();
    println("");

    test_combined();
    println("");

    println("========================================");
    println("         All Tests Completed!          ");
    println("========================================");
}
