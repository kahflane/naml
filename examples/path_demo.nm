use std::path::*;
use std::testing::*;

fn main() {
    println("=== Path Module Demo ===");
    println("");

    // Test path joining
    println("--- Path Joining ---");
    var parts: [string] = ["home", "user", "documents", "file.txt"];
    var joined: string = join(parts);
    print("join([home, user, documents, file.txt]) = ");
    println(joined);
    assert_eq_string(joined, "home/user/documents/file.txt", "join paths");

    // Test path normalization
    println("");
    println("--- Path Normalization ---");
    var messy_path: string = "a/b/../c/./d";
    var normalized: string = normalize(messy_path);
    print("normalize(\"a/b/../c/./d\") = ");
    println(normalized);
    assert_eq_string(normalized, "a/c/d", "normalize path");

    // Test absolute/relative checks
    println("");
    println("--- Absolute/Relative Checks ---");
    var abs_path: string = "/home/user/file.txt";
    var rel_path: string = "relative/path/file.txt";

    print("is_absolute(\"/home/user/file.txt\") = ");
    println(is_absolute(abs_path));
    assert_eq_bool(is_absolute(abs_path), true, "is_absolute for absolute path");

    print("is_absolute(\"relative/path/file.txt\") = ");
    println(is_absolute(rel_path));
    assert_eq_bool(is_absolute(rel_path), false, "is_absolute for relative path");

    print("is_relative(\"relative/path/file.txt\") = ");
    println(is_relative(rel_path));
    assert_eq_bool(is_relative(rel_path), true, "is_relative for relative path");

    print("has_root(\"/home/user/file.txt\") = ");
    println(has_root(abs_path));
    assert_eq_bool(has_root(abs_path), true, "has_root for absolute path");

    // Test path component extraction
    println("");
    println("--- Component Extraction ---");
    var test_path: string = "/home/user/documents/report.pdf";

    print("dirname(\"/home/user/documents/report.pdf\") = ");
    println(dirname(test_path));
    assert_eq_string(dirname(test_path), "/home/user/documents", "dirname");

    print("basename(\"/home/user/documents/report.pdf\") = ");
    println(basename(test_path));
    assert_eq_string(basename(test_path), "report.pdf", "basename");

    print("extension(\"/home/user/documents/report.pdf\") = ");
    println(extension(test_path));
    assert_eq_string(extension(test_path), "pdf", "extension");

    print("stem(\"/home/user/documents/report.pdf\") = ");
    println(stem(test_path));
    assert_eq_string(stem(test_path), "report", "stem");

    // Test extension modification
    println("");
    println("--- Extension Modification ---");
    var doc_path: string = "/docs/readme.md";
    var new_path: string = with_extension(doc_path, "txt");
    print("with_extension(\"/docs/readme.md\", \"txt\") = ");
    println(new_path);
    assert_eq_string(new_path, "/docs/readme.txt", "with_extension");

    // Test path components
    println("");
    println("--- Path Components ---");
    var unix_path: string = "/usr/local/bin";
    var comps: [string] = components(unix_path);
    print("components(\"/usr/local/bin\") = ");
    print("[");
    for (i: int, comp: string in comps) {
        if (i > 0) {
            print(", ");
        }
        print("\"");
        print(comp);
        print("\"");
    }
    println("]");

    // Test platform separator
    println("");
    println("--- Platform Info ---");
    var sep: string = separator();
    print("separator() = \"");
    print(sep);
    println("\"");
    assert_eq_string(sep, "/", "separator");

    // Test slash conversion
    println("");
    println("--- Slash Conversion ---");
    var win_style: string = "a\\b\\c";
    var to_forward: string = to_slash(win_style);
    print("to_slash(\"a\\\\b\\\\c\") = ");
    println(to_forward);
    assert_eq_string(to_forward, "a/b/c", "to_slash");

    var unix_style: string = "a/b/c";
    var from_forward: string = from_slash(unix_style);
    print("from_slash(\"a/b/c\") = ");
    println(from_forward);
    assert_eq_string(from_forward, "a/b/c", "from_slash");

    // Test path comparison
    println("");
    println("--- Path Comparison ---");
    var base: string = "/home/user";
    var full: string = "/home/user/docs/file.txt";

    print("starts_with(\"/home/user/docs/file.txt\", \"/home/user\") = ");
    println(starts_with(full, base));
    assert_eq_bool(starts_with(full, base), true, "starts_with");

    print("ends_with(\"/home/user/docs/file.txt\", \"file.txt\") = ");
    println(ends_with(full, "file.txt"));
    assert_eq_bool(ends_with(full, "file.txt"), true, "ends_with");

    // Test strip prefix
    println("");
    println("--- Strip Prefix ---");
    var stripped: string = strip_prefix(full, base);
    print("strip_prefix(\"/home/user/docs/file.txt\", \"/home/user\") = ");
    println(stripped);
    assert_eq_string(stripped, "docs/file.txt", "strip_prefix");

    println("");
    println("=== All tests complete! ===");
}
