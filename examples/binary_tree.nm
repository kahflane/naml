///
/// # Binary Search Tree
///
/// A BST implemented using parallel arrays.
/// Each node stores a value, left child index, and right child index.
/// -1 represents a null/empty child.
///
/// Operations: insert, search, find_min, find_max,
///             inorder, preorder, postorder, tree_size, tree_height.
///

use std::collections::arrays::{count, push};
use std::testing::*;

fn insert(vals: [int], lefts: [int], rights: [int], root: int, val: int) -> int {
    var idx: int = count(vals);
    push(vals, val);
    push(lefts, -1);
    push(rights, -1);

    if (root == -1) {
        return idx;
    }

    var cur: int = root;
    var placed: bool = false;
    while (not placed) {
        if (val < vals[cur]!) {
            if (lefts[cur]! == -1) {
                lefts[cur] = idx;
                placed = true;
            } else {
                cur = lefts[cur]!;
            }
        } else {
            if (rights[cur]! == -1) {
                rights[cur] = idx;
                placed = true;
            } else {
                cur = rights[cur]!;
            }
        }
    }
    return root;
}

fn search(vals: [int], lefts: [int], rights: [int], root: int, val: int) -> bool {
    var cur: int = root;
    while (cur != -1) {
        if (val == vals[cur]!) {
            return true;
        }
        if (val < vals[cur]!) {
            cur = lefts[cur]!;
        } else {
            cur = rights[cur]!;
        }
    }
    return false;
}

fn find_min(vals: [int], lefts: [int], root: int) -> int {
    if (root == -1) {
        return -1;
    }
    var cur: int = root;
    while (lefts[cur]! != -1) {
        cur = lefts[cur]!;
    }
    return vals[cur]!;
}

fn find_max(vals: [int], rights: [int], root: int) -> int {
    if (root == -1) {
        return -1;
    }
    var cur: int = root;
    while (rights[cur]! != -1) {
        cur = rights[cur]!;
    }
    return vals[cur]!;
}

fn tree_size(lefts: [int], rights: [int], node: int) -> int {
    if (node == -1) {
        return 0;
    }
    return 1 + tree_size(lefts, rights, lefts[node]!)
             + tree_size(lefts, rights, rights[node]!);
}

fn tree_height(lefts: [int], rights: [int], node: int) -> int {
    if (node == -1) {
        return 0;
    }
    var lh: int = tree_height(lefts, rights, lefts[node]!);
    var rh: int = tree_height(lefts, rights, rights[node]!);
    if (lh > rh) {
        return 1 + lh;
    }
    return 1 + rh;
}

fn inorder(vals: [int], lefts: [int], rights: [int], node: int) {
    if (node == -1) {
        return;
    }
    inorder(vals, lefts, rights, lefts[node]!);
    print("{} ", vals[node]!);
    inorder(vals, lefts, rights, rights[node]!);
}

fn preorder(vals: [int], lefts: [int], rights: [int], node: int) {
    if (node == -1) {
        return;
    }
    print("{} ", vals[node]!);
    preorder(vals, lefts, rights, lefts[node]!);
    preorder(vals, lefts, rights, rights[node]!);
}

fn postorder(vals: [int], lefts: [int], rights: [int], node: int) {
    if (node == -1) {
        return;
    }
    postorder(vals, lefts, rights, lefts[node]!);
    postorder(vals, lefts, rights, rights[node]!);
    print("{} ", vals[node]!);
}

fn main() {
    var vals: [int] = [];
    var lefts: [int] = [];
    var rights: [int] = [];
    var root: int = -1;

    println("=== Binary Search Tree Demo ===");
    println("");

    println("Inserting: 50, 30, 70, 20, 40, 60, 80");
    root = insert(vals, lefts, rights, root, 50);
    root = insert(vals, lefts, rights, root, 30);
    root = insert(vals, lefts, rights, root, 70);
    root = insert(vals, lefts, rights, root, 20);
    root = insert(vals, lefts, rights, root, 40);
    root = insert(vals, lefts, rights, root, 60);
    root = insert(vals, lefts, rights, root, 80);

    println("");
    println("Tree structure:");
    println("        50");
    println("       /  \\");
    println("     30    70");
    println("    / \\   / \\");
    println("  20  40 60  80");

    println("");
    print("Inorder:   ");
    inorder(vals, lefts, rights, root);
    println("");

    print("Preorder:  ");
    preorder(vals, lefts, rights, root);
    println("");

    print("Postorder: ");
    postorder(vals, lefts, rights, root);
    println("");

    println("");
    println("Size: {}", tree_size(lefts, rights, root));
    assert_eq(tree_size(lefts, rights, root), 7, "tree size should be 7");
    println("Height: {}", tree_height(lefts, rights, root));
    assert_eq(tree_height(lefts, rights, root), 3, "tree height should be 3");
    println("Min: {}", find_min(vals, lefts, root));
    assert_eq(find_min(vals, lefts, root), 20, "min should be 20");
    println("Max: {}", find_max(vals, rights, root));
    assert_eq(find_max(vals, rights, root), 80, "max should be 80");

    println("");
    println("Search 40: {}", search(vals, lefts, rights, root, 40));
    assert_true(search(vals, lefts, rights, root, 40), "should find 40");
    println("Search 25: {}", search(vals, lefts, rights, root, 25));
    assert_false(search(vals, lefts, rights, root, 25), "should not find 25");
    println("Search 80: {}", search(vals, lefts, rights, root, 80));
    assert_true(search(vals, lefts, rights, root, 80), "should find 80");
    println("Search 99: {}", search(vals, lefts, rights, root, 99));
    assert_false(search(vals, lefts, rights, root, 99), "should not find 99");

    println("");
    println("Inserting: 25, 35");
    root = insert(vals, lefts, rights, root, 25);
    root = insert(vals, lefts, rights, root, 35);
    print("Inorder:   ");
    inorder(vals, lefts, rights, root);
    println("");
    println("Size: {}", tree_size(lefts, rights, root));
    println("Height: {}", tree_height(lefts, rights, root));
}
