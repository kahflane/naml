///
/// HTTP Client - REST API Consumer
///
/// A  HTTP client example that:
/// - Demonstrates all HTTP methods (GET, POST, PUT, DELETE)
/// - Uses status() and body() to access response data
/// - Shows both default headers (none) and custom headers (some)
/// - Uses concurrent requests with spawn
/// - Verifies responses and aggregates statistics
///
/// Usage: Run a local HTTP server on port 8080 first, or use httpbin.org
///

use std::threads::{join, with_mutex};
use std::net::http::client::{get, post, put, delete, status, body};
use std::strings::{len, has};

fn main() {
    println("=== HTTP Client Demo ===");
    println("");

    // Statistics
    var requests_made: mutex<int> = with_mutex(0);
    var requests_success: mutex<int> = with_mutex(0);
    var requests_failed: mutex<int> = with_mutex(0);

    // Test 1: Simple GET request without custom headers
    println("Test 1: Simple GET request (no custom headers)");
    test_get_request("http://httpbin.org/get", none, requests_made, requests_success, requests_failed);
    println("");

    // Test 2: Another GET request
    println("Test 2: GET request to different endpoint");
    test_get_request("http://httpbin.org/headers", none, requests_made, requests_success, requests_failed);
    println("");

    // Test 3: POST request with JSON body
    println("Test 3: POST request with JSON body");
    test_post_request("http://httpbin.org/post", `{"name":"Alice","age":30}`, none, requests_made, requests_success, requests_failed);
    println("");

    // Test 4: PUT request
    println("Test 4: PUT request");
    test_put_request("http://httpbin.org/put", `{"name":"Bob","age":25}`, none, requests_made, requests_success, requests_failed);
    println("");

    // Test 5: DELETE request
    println("Test 5: DELETE request");
    test_delete_request("http://httpbin.org/delete", none, requests_made, requests_success, requests_failed);
    println("");

    // Test 6: Concurrent requests
    println("Test 6: Concurrent requests (3 parallel GETs)");
    spawn {
        test_get_request("http://httpbin.org/get?id=1", none, requests_made, requests_success, requests_failed);
    };
    spawn {
        test_get_request("http://httpbin.org/get?id=2", none, requests_made, requests_success, requests_failed);
    };
    spawn {
        test_get_request("http://httpbin.org/get?id=3", none, requests_made, requests_success, requests_failed);
    };
    join();
    println("");

    // Print final statistics
    println("=== HTTP Client Statistics ===");
    locked (made: int in requests_made) {
        println(fmt("Total requests made: {}", made));
    }
    locked (success: int in requests_success) {
        println(fmt("Successful requests: {}", success));
    }
    locked (failed: int in requests_failed) {
        println(fmt("Failed requests: {}", failed));
    }

    // Verify
    var made: int = 0;
    var success: int = 0;
    locked (m: int in requests_made) {
        made = m;
    }
    locked (s: int in requests_success) {
        success = s;
    }

    println("");
    if (made == 8) {
        println("PASS: All 8 requests were attempted");
    } else {
        println(fmt("Note: Expected 8 requests, made {}", made));
    }

    println("");
    println("HTTP Client demo finished.");
}

fn test_get_request(
    url: string,
    headers: option<map<string, string>>,
    requests_made: mutex<int>,
    requests_success: mutex<int>,
    requests_failed: mutex<int>
) {
    locked (m: int in requests_made) {
        m = m + 1;
    }

    println(fmt("  GET {}", url));

    var response: int = get(url, headers) catch e {
        println(fmt("  ERROR: {}", e.message));
        locked (f: int in requests_failed) {
            f = f + 1;
        }
        return;
    };

    // Use accessor functions to get response data
    var status_code: int = status(response);
    var body_data: bytes = body(response);
    var body_str: string = body_data as string;
    var body_len: int = len(body_str);

    println(fmt("  Status: {}", status_code));
    println(fmt("  Body length: {} bytes", body_len));

    if (status_code >= 200 && status_code < 300) {
        locked (s: int in requests_success) {
            s = s + 1;
        }
        println("  SUCCESS");
    } else {
        locked (f: int in requests_failed) {
            f = f + 1;
        }
        println(fmt("  FAILED: Unexpected status {}", status_code));
    }
}

fn test_post_request(
    url: string,
    body_content: string,
    headers: option<map<string, string>>,
    requests_made: mutex<int>,
    requests_success: mutex<int>,
    requests_failed: mutex<int>
) {
    locked (m: int in requests_made) {
        m = m + 1;
    }

    println(fmt("  POST {}", url));
    println(fmt("  Body: {}", body_content));

    var body_bytes: bytes = body_content as bytes;
    var response: int = post(url, body_bytes, headers) catch e {
        println(fmt("  ERROR: {}", e.message));
        locked (f: int in requests_failed) {
            f = f + 1;
        }
        return;
    };

    var status_code: int = status(response);
    var response_body: bytes = body(response);
    var body_len: int = len(response_body as string);

    println(fmt("  Status: {}", status_code));
    println(fmt("  Response body length: {} bytes", body_len));

    if (status_code >= 200 && status_code < 300) {
        locked (s: int in requests_success) {
            s = s + 1;
        }
        println("  SUCCESS");
    } else {
        locked (f: int in requests_failed) {
            f = f + 1;
        }
        println(fmt("  FAILED: Unexpected status {}", status_code));
    }
}

fn test_put_request(
    url: string,
    body_content: string,
    headers: option<map<string, string>>,
    requests_made: mutex<int>,
    requests_success: mutex<int>,
    requests_failed: mutex<int>
) {
    locked (m: int in requests_made) {
        m = m + 1;
    }

    println(fmt("  PUT {}", url));
    println(fmt("  Body: {}", body_content));

    var body_bytes: bytes = body_content as bytes;
    var response: int = put(url, body_bytes, headers) catch e {
        println(fmt("  ERROR: {}", e.message));
        locked (f: int in requests_failed) {
            f = f + 1;
        }
        return;
    };

    var status_code: int = status(response);
    println(fmt("  Status: {}", status_code));

    if (status_code >= 200 && status_code < 300) {
        locked (s: int in requests_success) {
            s = s + 1;
        }
        println("  SUCCESS");
    } else {
        locked (f: int in requests_failed) {
            f = f + 1;
        }
        println(fmt("  FAILED: Unexpected status {}", status_code));
    }
}

fn test_delete_request(
    url: string,
    headers: option<map<string, string>>,
    requests_made: mutex<int>,
    requests_success: mutex<int>,
    requests_failed: mutex<int>
) {
    locked (m: int in requests_made) {
        m = m + 1;
    }

    println(fmt("  DELETE {}", url));

    var response: int = delete(url, headers) catch e {
        println(fmt("  ERROR: {}", e.message));
        locked (f: int in requests_failed) {
            f = f + 1;
        }
        return;
    };

    var status_code: int = status(response);
    println(fmt("  Status: {}", status_code));

    if (status_code >= 200 && status_code < 300) {
        locked (s: int in requests_success) {
            s = s + 1;
        }
        println("  SUCCESS");
    } else {
        locked (f: int in requests_failed) {
            f = f + 1;
        }
        println(fmt("  FAILED: Unexpected status {}", status_code));
    }
}
