pub fn next_head_x(hx: int, dir: int) -> int {
    if (dir == 1) {
        return hx + 1;
    }
    if (dir == 3) {
        return hx - 1;
    }
    return hx;
}

pub fn next_head_y(hy: int, dir: int) -> int {
    if (dir == 0) {
        return hy - 1;
    }
    if (dir == 2) {
        return hy + 1;
    }
    return hy;
}

pub fn is_opposite(current: int, next: int) -> bool {
    if (current == 0 and next == 2) { return true; }
    if (current == 2 and next == 0) { return true; }
    if (current == 1 and next == 3) { return true; }
    if (current == 3 and next == 1) { return true; }
    return false;
}

pub fn hit_wall(x: int, y: int, w: int, h: int) -> bool {
    if (x < 0 or x >= w or y < 0 or y >= h) {
        return true;
    }
    return false;
}
